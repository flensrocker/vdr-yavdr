Description: Patch for VDR to support reading its arguments from files.
Origin: https://github.com/flensrocker/vdr/tree/conf.d-args
Forwarded: no
Author: Lars Hanisch <dvb@flensrocker.de>

--- a/Make.config.template
+++ b/Make.config.template
@@ -38,6 +38,7 @@
 
 #VIDEODIR  = /srv/vdr/video
 #CONFDIR   = /var/lib/vdr
+#ARGSDIR   = /etc/vdr/conf.d
 #CACHEDIR  = /var/cache/vdr
 
 # Overrides for preset/legacy configurations:
--- a/Makefile
+++ b/Makefile
@@ -31,6 +31,7 @@
 DESTDIR   ?=
 VIDEODIR  ?= /srv/vdr/video
 CONFDIR   ?= /var/lib/vdr
+ARGSDIR   ?= /etc/vdr/conf.d
 CACHEDIR  ?= /var/cache/vdr
 
 PREFIX    ?= /usr/local
@@ -66,7 +67,7 @@
 
 SILIB    = $(LSIDIR)/libsi.a
 
-OBJS = audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbci.o\
+OBJS = args.o audio.o channels.o ci.o config.o cutter.o device.o diseqc.o dvbdevice.o dvbci.o\
        dvbplayer.o dvbspu.o dvbsubtitle.o eit.o eitscan.o epg.o filter.o font.o i18n.o interface.o keys.o\
        lirc.o menu.o menuitems.o nit.o osdbase.o osd.o pat.o player.o plugin.o positioner.o\
        receiver.o recorder.o recording.o remote.o remux.o ringbuffer.o sdt.o sections.o shutdown.o\
@@ -100,6 +101,7 @@
 DEFINES += -DVIDEODIR=\"$(VIDEODIR)\"
 DEFINES += -DCONFDIR=\"$(CONFDIR)\"
 DEFINES += -DCACHEDIR=\"$(CACHEDIR)\"
+DEFINES += -DARGSDIR=\"$(ARGSDIR)\"
 DEFINES += -DRESDIR=\"$(RESDIR)\"
 DEFINES += -DPLUGINDIR=\"$(LIBDIR)\"
 DEFINES += -DLOCDIR=\"$(LOCDIR)\"
@@ -142,6 +144,7 @@
 	@echo "bindir=$(BINDIR)" > $@
 	@echo "mandir=$(MANDIR)" >> $@
 	@echo "configdir=$(CONFDIR)" >> $@
+	@echo "argsdir=$(ARGSDIR)" >> $@
 	@echo "videodir=$(VIDEODIR)" >> $@
 	@echo "cachedir=$(CACHEDIR)" >> $@
 	@echo "resdir=$(RESDIR)" >> $@
@@ -260,6 +263,7 @@
 install-dirs:
 	@mkdir -p $(DESTDIR)$(VIDEODIR)
 	@mkdir -p $(DESTDIR)$(CONFDIR)
+	@mkdir -p $(DESTDIR)$(ARGSDIR)
 	@mkdir -p $(DESTDIR)$(CACHEDIR)
 	@mkdir -p $(DESTDIR)$(RESDIR)
 
--- /dev/null
+++ b/args.c
@@ -0,0 +1,199 @@
+/*
+ * args.c: Read arguments from files
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: $
+ */
+
+#include "args.h"
+#include <unistd.h>
+
+class cArgsSection : public cListObject {
+private:
+  cString name;
+  cStringList args;
+
+public:
+  cArgsSection(const char *Name)
+  {
+    name = Name;
+  };
+  
+  virtual ~cArgsSection(void)
+  {
+  };
+
+  void AddArg(const char *Arg)
+  {
+    if (Arg != NULL)
+       args.Append(strdup(Arg));
+  };
+
+  const char *Name(void)
+  {
+    return *name;
+  };
+
+  const cStringList &Args(void)
+  {
+    return args;
+  };
+};
+
+class cArgsSections : public cList<cArgsSection> {
+public:
+  cArgsSection *FindSection(const char *Name)
+  {
+    if (Name == NULL)
+       return NULL;
+
+    cArgsSection *s = First();
+    while ((s != NULL) && (strcmp(s->Name(), Name) != 0))
+          s = Next(s);
+    return s;
+  };
+};
+
+cArgs::cArgs(const char *Argv0)
+{
+  argv0 = Argv0;
+  argc = 0;
+  argv = NULL;
+}
+
+cArgs::~cArgs(void)
+{
+  if (argv != NULL) {
+     for (int i = 0; i < argc; i++)
+         free(argv[i]);
+     delete [] argv;
+     }
+}
+
+bool cArgs::ReadDirectory(const char *Directory)
+{
+  if (argv != NULL) {
+     for (int i = 0; i < argc; i++)
+         free(argv[i]);
+     delete [] argv;
+     }
+  argc = 0;
+  argv = NULL;
+
+  cFileNameList files(Directory, false);
+  if (files.Size() == 0)
+     return false;
+
+  bool result = true;
+  cArgsSections sections;
+  cArgsSection *vdrSection = NULL;
+  cArgsSection *currentSection = NULL;
+  for (int i = 0; i < files.Size(); i++) {
+      cString fileName = AddDirectory(Directory, files.At(i));
+      struct stat fs;
+      if ((access(*fileName, F_OK) != 0) || (stat(*fileName, &fs) != 0) || S_ISDIR(fs.st_mode))
+         continue;
+
+      FILE *f = fopen(*fileName, "r");
+      if (f) {
+         char *s;
+         int line = 0;
+         cReadLine ReadLine;
+         while ((s = ReadLine.Read(f)) != NULL) {
+               line++;
+               s = stripspace(skipspace(s));
+               if (!isempty(s) && (s[0] != '#')) {
+                  if (startswith(s, "[") && endswith(s, "]")) {
+                     s[strlen(s) - 1] = 0;
+                     s++;
+                     if (strcmp(s, "vdr") == 0) {
+                        currentSection = sections.FindSection(s);
+                        if (currentSection == NULL) {
+                           vdrSection = currentSection = new cArgsSection(s);
+                           sections.Add(currentSection);
+                           }
+                        }
+                     else {
+                        currentSection = new cArgsSection(s);
+                        sections.Add(currentSection);
+                        }
+                     }
+                  else {
+                     if (!startswith(s, "-")) {
+                        result = false;
+                        esyslog("ERROR: args file %s, line %d must start with a hyphen (%s)", *fileName, line, s);
+                        break;
+                        }
+
+                     if (currentSection == NULL) {
+                        result = false;
+                        esyslog("ERROR: args file %s, line %d must start with a section", *fileName, line);
+                        break;
+                        }
+
+                     if ((strlen(s) > 2) && (s[1] != '-')) { // short option, split at first space
+                        char *p = strchr(s, ' ');
+                        if (p == NULL)
+                           currentSection->AddArg(s);
+                        else {
+                           *p = 0;
+                           p++;
+                           currentSection->AddArg(s);
+                           currentSection->AddArg(p);
+                           }
+                        }
+                     else
+                        currentSection->AddArg(s);
+                     }
+                  }
+               }
+         fclose(f);
+         }
+       if (!result)
+          return false;
+      }
+
+  argc = 1; // for argv0
+  if (vdrSection != NULL) {
+     argc += vdrSection->Args().Size();
+     argc += (sections.Count() - 1) * 2;
+     }
+  else
+     argc += sections.Count() * 2;
+
+  argv = new char*[argc];
+  argv[0] = strdup(*argv0);
+  int c = 1;
+  if (vdrSection != NULL) {
+     for (int i = 0; i < vdrSection->Args().Size(); i++) {
+         argv[c] = strdup(vdrSection->Args().At(i));
+         c++;
+         }
+     }
+  for (cArgsSection *s = sections.First(); s; s = sections.Next(s)) {
+      if (s == vdrSection)
+         continue;
+
+      argv[c] = strdup("-P");
+      c++;
+
+      cString arg = cString::sprintf("%s", s->Name());
+      for (int i = 0; i < s->Args().Size(); i++)
+          arg = cString::sprintf("%s %s", *arg, s->Args().At(i));
+      argv[c] = strdup(*arg);
+      c++;
+      }
+  return result;
+}
+  
+int cArgs::GetArgc(void) const
+{
+  return argc;
+}
+
+char **cArgs::GetArgv(void) const
+{
+  return argv;
+}
--- /dev/null
+++ b/args.h
@@ -0,0 +1,31 @@
+/*
+ * args.h: Read arguments from files
+ *
+ * See the main source file 'vdr.c' for copyright information and
+ * how to reach the author.
+ *
+ * $Id: $
+ */
+
+#ifndef __ARGS_H
+#define __ARGS_H
+
+#include "tools.h"
+
+class cArgs {
+private:
+  cString argv0;
+  int     argc;
+  char  **argv;
+
+public:
+  cArgs(const char *Argv0);
+  ~cArgs(void);
+
+  bool ReadDirectory(const char *Directory);
+  
+  int GetArgc(void) const;
+  char **GetArgv(void) const;
+  };
+
+#endif //__ARGS_H
--- a/vdr.c
+++ b/vdr.c
@@ -36,6 +36,7 @@
 #include <sys/prctl.h>
 #include <termios.h>
 #include <unistd.h>
+#include "args.h"
 #include "audio.h"
 #include "channels.h"
 #include "config.h"
@@ -188,6 +189,7 @@
 #define DEFAULTWATCHDOG     0 // seconds
 #define DEFAULTVIDEODIR VIDEODIR
 #define DEFAULTCONFDIR dd(CONFDIR, VideoDirectory)
+#define DEFAULTARGSDIR dd(ARGSDIR, "/etc/vdr/conf.d")
 #define DEFAULTCACHEDIR dd(CACHEDIR, VideoDirectory)
 #define DEFAULTRESDIR dd(RESDIR, ConfigDirectory)
 #define DEFAULTPLUGINDIR PLUGINDIR
@@ -225,6 +227,15 @@
   VdrUser = VDR_USER;
 #endif
 
+  cArgs *args = NULL;
+  if (argc == 1) {
+     args = new cArgs(argv[0]);
+     if (args->ReadDirectory(DEFAULTARGSDIR)) {
+        argc = args->GetArgc();
+        argv = args->GetArgv();
+        }
+     }
+
   cVideoDirectory::SetName(VideoDirectory);
   cPluginManager PluginManager(DEFAULTPLUGINDIR);
 
@@ -253,6 +264,7 @@
       { "port",     required_argument, NULL, 'p' },
       { "record",   required_argument, NULL, 'r' },
       { "resdir",   required_argument, NULL, 'r' | 0x100 },
+      { "showargs", no_argument,       NULL, 's' | 0x200 },
       { "shutdown", required_argument, NULL, 's' },
       { "split",    no_argument,       NULL, 's' | 0x100 },
       { "terminal", required_argument, NULL, 't' },
@@ -427,6 +439,18 @@
           case 's' | 0x100:
                     Setup.SplitEditedFiles = 1;
                     break;
+          case 's' | 0x200: {
+                    cArgs a(argv[0]);
+                    if (!a.ReadDirectory(DEFAULTARGSDIR)) {
+                       fprintf(stderr, "vdr: can't read arguments from directory: %s\n", DEFAULTARGSDIR);
+                       return 2;
+                       }
+                    int c = a.GetArgc();
+                    char **v = a.GetArgv();
+                    for (int i = 1; i < c; i++)
+                        printf("%s\n", v[i]);
+                    return 0;
+                    }
           case 't': Terminal = optarg;
                     if (access(Terminal, R_OK | W_OK) < 0) {
                        fprintf(stderr, "vdr: can't access terminal: %s\n", Terminal);
@@ -547,6 +571,7 @@
                "  -s CMD,   --shutdown=CMD call CMD to shutdown the computer\n"
                "            --split        split edited files at the editing marks (only\n"
                "                           useful in conjunction with --edit)\n"
+               "            --showargs     print the arguments read from %s and exit\n"
                "  -t TTY,   --terminal=TTY controlling tty\n"
                "  -u USER,  --user=USER    run as user USER; only applicable if started as\n"
                "                           root\n"
@@ -569,6 +594,7 @@
                DEFAULTLOCDIR,
                DEFAULTSVDRPPORT,
                DEFAULTRESDIR,
+               DEFAULTARGSDIR,
                DEFAULTVIDEODIR,
                DEFAULTWATCHDOG
                );
